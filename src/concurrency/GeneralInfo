Chapter 2
---------
Потокобезопасность - это по сути управление доступом к состоянию, и в частности к совместному (shared)
мутируемогу состоянию (mutable state).

Синхронизацию в Java обеспечивают следующие конструкции
- ключевое слово Synchronized (эксклюзивная блокировка)
- атомарная переменная
- volatile переменная
- явные замки

При проектировании потокобезопасных классов, хорошие объектно-ориентированные технические решения:
- Инкапсуляция
- Немутируемость
- Четкая спецификация инвариантов


Класс является потокобезопасным, если он ведет себя правильно, во время доступа из многочисленных потоков, независимо
от того, как выполнение этих потоков планируется или перемежается рабочей средой, и без дополнительной синхронизации или
другой координации со стороны вызывающего кода

Race state - состояние гонки, когда один поток выполняет неАтомарную операции например (проверка + запись или
чтение + изменение + запись), и в этот момент второй поток пытается выполнить составные действия, и в результате временного
размеживания нарушается консистентность операции

concurrent.atomic - классы атомарных операций

========================================================================================================================
Chapter 3
----------
Synchronized - затрагивает следующие важные аспекты
- Атомарность
- Демаркация "Критических секций"
- Видимость памяти (Memory visibility)

Переупорядочивание(reordering) - учаток кода в котором нет гарантии, что операции в одном потоке будут выполняться в
заданном программой порядке. Сделано это с целью оптимизации производительности современного многопроцессорного оборудования.
При отсутствии синхронизации модель памяти Java позволяет компилятору переупорядочивать операции и значения кэша в регистрах,
а процессорам - переупорядочивать операции и значения кэша в кэшах, специфичных для процессора.
Чтение данных без синхронизации равносильно использованию уровня изоляции READ_UNCOMMITTED в бд.

Без синхронизации компилятор, процессор и рабочая среда могут запутать порядок выполнения операций. Не стоит ожидать
естественного порядка действий памяти в недостаточно синхронизированных многопоточных программах.

Гарантия видимости - еще одна причина синхронизации всех потоков на одинаковом замке во время доступа к
совместной мутируемой переменной. Чтобы обеспечить видимость актуальных значений совместных волатильных переменных,
синхронизируйте  читающие и пишущие потоки на общем замке.
-------------
Volatile переменная - переменная которая для компилятора и рабочей среды, является совместной для потоков,
те операции над ней не будут переупорядочены с другими операциями в памяти. Они не кэшируются в регистрах или кэшах,
где данные скрыты от других процессоров, поэтому их чтение всегда возвращает актуальное значения записи.

Обращение к volatile переменной не может побудить выполняющий поток к блокировке, что делает ее легковесным
мехинизмом синхронизации. Запись в валатильную переменную похожа на выход и синхронизрованного блока, а чтение на вход.
Волатильные переменные удобны и часто используются в качестве флажка завершения, прерывания или статуса.

Блокировка может гарантировать как видимость, так и атомарность, волатильные переменные гарантируют только видимость!
-------------
Публикация объекта.

Объект который не вовремя публикуется, называется ускользнувшим.

Примеры ускользнувших объектов:
- public метод возвращает private переменную, инициализированную объектом.
- передача в другой метод private переменную, инициализированную объектом.
- публикация экземпляра его внутреннего класса, тк экземпляр внутреннего класса содержит неявную ссылку на окомляющий его класс.

Объект с ускользнувшей ссылкой this, считается ненадлежаще сконстуированным. Не позволяйте ссылке this ускользнуть
во время констуирования( например запуск потока из конструктора, чтобы зарегистировать слушателя событий или
запустить поток конструктора, воспользуйтесь приватным конструктором и публичным фабричным методом)
--------------
Ограничение одним потоком

Существует несколько способов ограничения одним потоком:
- Swing мехинизм планирования invokeLater
- JDBC пул потоков для Connection
- Ограничением стеком (при ограничение стеком объект может быть достигнут только через локальные переменные,
они внутренне ограничены стеком выполняющего потока3)
- ThreadLocal (позволяет ассоциировать каждое значение в потоке с объектом, владеющим этим значением. Он предоставляет
методы get() и set(), поддерживающие отдельную копию значения для каждого потока, который его использует, поэтому
метод get() возвращает самое последнее значение, переданное в set) Example ThreadLocalConnection
--------------
Немутируемость
Немутируемые обьекты всегда являются потокобезопасными!

Объект является немутируемым, если
- его состояние невозможно изменить после конструирования
- все поля являются финальными (и если финальное поле инициализируется объектом, то связанный объект тоже немутируемый)
- он надлежаще сконструирован(ссылка this не ускользнула)
-------------------
Безопасная публикация

Немутируемые обьекты могут безопасно использоваться потоками, даже без надлежащей синхронизации и публикации объекта,
однако если финальные поля имеют ссылки на мутируемые объеты, то синхронизация попрежнему необходима.

Приемы безопасной публикации объекта: (ссылка на него и его состояние видна всем потокам в одно и тоже время)
- инициализация объектной ссылки из статического инициализатора
- сохранение ссылки на него в волатильном поле, либо в AtomicReference
- сохранение ссылки на него в финальном поле, надлежаще сконструированного объекта
- сохранение ссылки на него в поле, которое надлежаще защищается замком

public static Holder holder = new Holder(42);
Статические инициализаторы выполняются в Jvm машиной во время инициализации класса, гарантируя дальнейшую безопасную
публикацию инициализированных объектов